/* Alloy Game Engine
 * By AlloyTeam http://www.alloyteam.com/
 * Github: https://github.com/AlloyTeam/Nuclear
 * MIT Licensed.
 */
!function (e, t) { "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? module.exports = t() : e.Nuclear = t() }(this, function () {
    var e = {}
    return function () {
        var t = !1, r = /xyz/.test(function () { xyz }) ? /\b_super\b/ : /.*/, n = function () { }
        n.extend = function (e) {
            function o() { !t && this.ctor && this.ctor.apply(this, arguments) } var i = this.prototype
            t = !0
            var s = new this
            t = !1
            for (var a in e) "statics" != a && (s[a] = "function" == typeof e[a] && "function" == typeof i[a] && r.test(e[a]) ? function (e, t) {
                return function () {
                    var r = this._super
                    this._super = i[e]
                    var n = t.apply(this, arguments)
                    return this._super = r, n
                }
            }(a, e[a]) : e[a])
            for (var p in this) this.hasOwnProperty(p) && "extend" != p && (o[p] = this[p])
            if (o.prototype = s, e.statics) for (var a in e.statics) e.statics.hasOwnProperty(a) && (o[a] = e.statics[a], "ctor" == a && o[a]())
            return o.prototype.constructor = o, o.extend = n.extend, o.implement = function (e) { for (var t in e) s[t] = e[t] }, o
        }, e.Class = n
    }(), e.renderList = [], e.extend = function (t) { return t.ctor = function (r, n) { this.option = n, this.parent = document.querySelector(r), t.didMount && t.didMount.call(this), e.observe(this.option, e.debounce(e.render, 50)), e.renderList.push({ tpl: this.render(), data: this.option, parent: this.parent, eventBinding: t.eventBinding, self: this }), e.render() }, e.Class.extend(t) }, e.render = function () {
        for (var t = 0, r = e.renderList.length; r > t; t++) {
            var n = e.renderList[t]
            n.self.node && n.parent.removeChild(n.self.node), n.parent.insertAdjacentHTML("beforeEnd", e.Tpl.render(n.tpl, n.data)), n.self.node = n.parent.lastChild, n.eventBinding && n.eventBinding.call(n.self)
        }
    }, e.debounce = function (e, t, r) {
        var n
        return function () {
            var o = this, i = arguments, s = function () { n = null, r || e.apply(o, i) }, a = r && !n
            clearTimeout(n), n = setTimeout(s, t), a && e.apply(o, i)
        }
    }, function () {
        var t = function (e, r, n) {
            var o = function (e, r, n) {
                e.$observer || (e.$observer = this)
                var o = e.$observer, i = []
                t.isArray(e) && (0 === e.length && (e.$observeProps = {}, e.$observeProps.$observerPath = "#"), o.mock(e))
                for (var s in e) e.hasOwnProperty(s) && (n ? t.isArray(r) && t.isInArray(r, s) ? (i.push(s), o.watch(e, s)) : t.isString(r) && s == r && (i.push(s), o.watch(e, s)) : (i.push(s), o.watch(e, s)))
                o.target = e, o.propertyChangedHandler || (o.propertyChangedHandler = [])
                var a = n ? n : r
                o.propertyChangedHandler.push({ all: !n, propChanged: a, eventPropArr: i })
            }
            return o.prototype = {
                onPropertyChanged: function (e, r, n, o, i) { if (r !== n && this.propertyChangedHandler) for (var s = t._getRootName(e, i), a = 0, p = this.propertyChangedHandler.length; p > a; a++) { var c = this.propertyChangedHandler[a]; (c.all || t.isInArray(c.eventPropArr, s) || 0 === s.indexOf("Array-")) && c.propChanged.call(this.target, e, r, n, i) } 0 !== e.indexOf("Array-") && "object" == typeof r && this.watch(o, e, o.$observeProps.$observerPath) }, mock: function (e) {
                    var r = this
                    t.methods.forEach(function (n) {
                        e[n] = function () {
                            var e = Array.prototype.slice.call(this, 0), o = Array.prototype[n].apply(this, Array.prototype.slice.call(arguments))
                            if (RegExp("\\b" + n + "\\b").test(t.triggerStr)) {
                                for (var i in this) this.hasOwnProperty(i) && !t.isFunction(this[i]) && r.watch(this, i, this.$observeProps.$observerPath)
                                r.onPropertyChanged("Array-" + n, this, e, this, this.$observeProps.$observerPath)
                            } return o
                        }
                    })
                }, watch: function (e, r, n) {
                    if ("$observeProps" !== r && "$observer" !== r && !t.isFunction(e[r])) {
                        e.$observeProps || (e.$observeProps = {}), void 0 !== n ? e.$observeProps.$observerPath = n : e.$observeProps.$observerPath = "#"
                        var o = this, i = e.$observeProps[r] = e[r]
                        if (Object.defineProperty(e, r, {
                            get: function () { return this.$observeProps[r] }, set: function (t) {
                        var n = this.$observeProps[r]
                        this.$observeProps[r] = t, o.onPropertyChanged(r, t, n, this, e.$observeProps.$observerPath)
                        }
                        }), "object" == typeof i) {
                            t.isArray(i) && (this.mock(i), 0 === i.length && (i.$observeProps || (i.$observeProps = {}), void 0 !== n ? i.$observeProps.$observerPath = n : i.$observeProps.$observerPath = "#"))
                            for (var s in i) i.hasOwnProperty(s) && this.watch(i, s, e.$observeProps.$observerPath + "-" + r)
                        }
                    }
                }
            }, new o(e, r, n)
        }
        t.methods = ["concat", "every", "filter", "forEach", "indexOf", "join", "lastIndexOf", "map", "pop", "push", "reduce", "reduceRight", "reverse", "shift", "slice", "some", "sort", "splice", "unshift", "toLocaleString", "toString", "size"], t.triggerStr = "concat,pop,push,reverse,shift,sort,splice,unshift,size", t.isArray = function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, t.isString = function (e) { return "string" == typeof e }, t.isInArray = function (e, t) {
            for (var r = e.length; --r > -1;) if (t === e[r]) return !0
            return !1
        }, t.isFunction = function (e) { return "[object Function]" == Object.prototype.toString.call(e) }, t.twoWay = function (e, r, n, o) { "object" == typeof e[r] && "object" == typeof n[o] ? (t(e, r, function () { n[o] = this[r] }), t(n, o, function () { e[r] = this[o] })) : (t(e, r, function (e, t) { n[o] = t }), t(n, o, function (t, n) { e[r] = n })) }, t._getRootName = function (e, t) { return "#" === t ? e : t.split("-")[1] }, t.add = function (e, t, r) {
            e[t] = r
            var n = e.$observer
            n.watch(e, t)
        }, Array.prototype.size = function (e) { this.length = e }, e.observe = t
    }(), function (t, r) { e.Tpl = {}, r(e.Tpl) }(this, function (e) {
        function t(e) { return "function" == typeof e } function r(e) { return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&") } function n(e, t) { return v.call(e, t) } function o(e) { return !n(d, e) } function i(e) { return (e + "").replace(/[&<>"'\/]/g, function (e) { return y[e] }) } function s(t, n) {
            function i() {
                if (m && !x) for (; y.length;) delete d[y.pop()]
                else y = []
                m = !1, x = !1
            } function s(e) {
                if ("string" == typeof e && (e = e.split(b, 2)), !l(e) || 2 !== e.length) throw Error("Invalid tags: " + e)
                u = RegExp(r(e[0]) + "\\s*"), h = RegExp("\\s*" + r(e[1])), f = RegExp("\\s*" + r("}" + e[1]))
            } if (!t) return []
            var u, h, f, v = [], d = [], y = [], m = !1, x = !1
            s(n || e.tags)
            for (var A, k, C, j, O, S, E = new c(t) ; !E.eos() ;) {
                if (A = E.pos, C = E.scanUntil(u)) for (var T = 0, U = C.length; U > T; ++T) j = C.charAt(T), o(j) ? y.push(d.length) : x = !0, d.push(["text", j, A, A + 1]), A += 1, "\n" === j && i()
                if (!E.scan(u)) break
                if (m = !0, k = E.scan($) || "name", E.scan(g), "=" === k ? (C = E.scanUntil(w), E.scan(w), E.scanUntil(h)) : "{" === k ? (C = E.scanUntil(f), E.scan(P), E.scanUntil(h), k = "&") : C = E.scanUntil(h), !E.scan(h)) throw Error("Unclosed tag at " + E.pos)
                if (O = [k, C, A, E.pos], d.push(O), "#" === k || "^" === k) v.push(O)
                else if ("/" === k) {
                    if (S = v.pop(), !S) throw Error('Unopened section "' + C + '" at ' + A)
                    if (S[1] !== C) throw Error('Unclosed section "' + S[1] + '" at ' + A)
                } else "name" === k || "{" === k || "&" === k ? x = !0 : "=" === k && s(C)
            } if (S = v.pop()) throw Error('Unclosed section "' + S[1] + '" at ' + E.pos)
            return p(a(d))
        } function a(e) {
            for (var t, r, n = [], o = 0, i = e.length; i > o; ++o) t = e[o], t && ("text" === t[0] && r && "text" === r[0] ? (r[1] += t[1], r[3] = t[3]) : (n.push(t), r = t))
            return n
        } function p(e) {
            for (var t, r, n = [], o = n, i = [], s = 0, a = e.length; a > s; ++s) switch (t = e[s], t[0]) {
                case "#": case "^": o.push(t), i.push(t), o = t[4] = []
                    break
                case "/": r = i.pop(), r[5] = t[2], o = i.length > 0 ? i[i.length - 1][4] : n
                    break
                default: o.push(t)
            } return n
        } function c(e) { this.string = e, this.tail = e, this.pos = 0 } function u(e, t) { this.view = e, this.cache = { ".": this.view }, this.parent = t } function h() { this.cache = {} } var f = Object.prototype.toString, l = Array.isArray || function (e) { return "[object Array]" === f.call(e) }, v = RegExp.prototype.test, d = /\S/, y = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" }, g = /\s*/, b = /\s+/, w = /\s*=/, P = /\s*\}/, $ = /#|\^|\/|>|\{|&|=|!/
        c.prototype.eos = function () { return "" === this.tail }, c.prototype.scan = function (e) {
            var t = this.tail.match(e)
            if (!t || 0 !== t.index) return ""
            var r = t[0]
            return this.tail = this.tail.substring(r.length), this.pos += r.length, r
        }, c.prototype.scanUntil = function (e) {
            var t, r = this.tail.search(e)
            switch (r) {
                case -1: t = this.tail, this.tail = ""
                    break
                case 0: t = ""
                    break
                default: t = this.tail.substring(0, r), this.tail = this.tail.substring(r)
            } return this.pos += t.length, t
        }, u.prototype.push = function (e) { return new u(e, this) }, u.prototype.lookup = function (e) {
            var r, n = this.cache
            if (e in n) r = n[e]
            else {
                for (var o, i, s = this, a = !1; s;) {
                    if (e.indexOf(".") > 0) for (r = s.view, o = e.split("."), i = 0; null != r && i < o.length;) i === o.length - 1 && null != r && (a = "object" == typeof r && r.hasOwnProperty(o[i])), r = r[o[i++]]
                    else null != s.view && "object" == typeof s.view && (r = s.view[e], a = s.view.hasOwnProperty(e))
                    if (a) break
                    s = s.parent
                } n[e] = r
            } return t(r) && (r = r.call(this.view)), r
        }, h.prototype.clearCache = function () { this.cache = {} }, h.prototype.parse = function (e, t) {
            var r = this.cache, n = r[e]
            return null == n && (n = r[e] = s(e, t)), n
        }, h.prototype.render = function (e, t, r) {
            var n = this.parse(e), o = t instanceof u ? t : new u(t)
            return this.renderTokens(n, o, r, e)
        }, h.prototype.renderTokens = function (e, t, r, n) {
            for (var o, i, s, a = "", p = 0, c = e.length; c > p; ++p) s = void 0, o = e[p], i = o[0], "#" === i ? s = this.renderSection(o, t, r, n) : "^" === i ? s = this.renderInverted(o, t, r, n) : ">" === i ? s = this.renderPartial(o, t, r, n) : "&" === i ? s = this.unescapedValue(o, t) : "name" === i ? s = this.escapedValue(o, t) : "text" === i && (s = this.rawValue(o)), void 0 !== s && (a += s)
            return a
        }, h.prototype.renderSection = function (e, r, n, o) {
            function i(e) { return s.render(e, r, n) } var s = this, a = "", p = r.lookup(e[1])
            if (p) {
                if (l(p)) for (var c = 0, u = p.length; u > c; ++c) a += this.renderTokens(e[4], r.push(p[c]), n, o)
                else if ("object" == typeof p || "string" == typeof p || "number" == typeof p) a += this.renderTokens(e[4], r.push(p), n, o)
                else if (t(p)) {
                    if ("string" != typeof o) throw Error("Cannot use higher-order sections without the original template")
                    p = p.call(r.view, o.slice(e[3], e[5]), i), null != p && (a += p)
                } else a += this.renderTokens(e[4], r, n, o)
                return a
            }
        }, h.prototype.renderInverted = function (e, t, r, n) {
            var o = t.lookup(e[1])
            return !o || l(o) && 0 === o.length ? this.renderTokens(e[4], t, r, n) : void 0
        }, h.prototype.renderPartial = function (e, r, n) {
            if (n) {
                var o = t(n) ? n(e[1]) : n[e[1]]
                return null != o ? this.renderTokens(this.parse(o), r, n, o) : void 0
            }
        }, h.prototype.unescapedValue = function (e, t) {
            var r = t.lookup(e[1])
            return null != r ? r : void 0
        }, h.prototype.escapedValue = function (t, r) {
            var n = r.lookup(t[1])
            return null != n ? e.escape(n) : void 0
        }, h.prototype.rawValue = function (e) { return e[1] }, e.name = "mustache.js", e.version = "2.0.0", e.tags = ["{{", "}}"]
        var m = new h
        e.clearCache = function () { return m.clearCache() }, e.parse = function (e, t) { return m.parse(e, t) }, e.render = function (e, t, r) { return m.render(e, t, r) }, e.to_html = function (r, n, o, i) {
            var s = e.render(r, n, o)
            return t(i) ? void i(s) : s
        }, e.escape = i, e.Scanner = c, e.Context = u, e.Writer = h
    }), e
})
